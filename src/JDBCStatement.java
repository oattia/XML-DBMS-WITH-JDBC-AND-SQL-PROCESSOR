import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.LinkedList;
import java.util.Queue;

import org.apache.log4j.Logger;

import DBMS.*;

/**
 * The object used for executing a static SQL statement and returning the
 * results it produces.
 * 
 * By default, only one ResultSet object per Statement object can be open at the
 * same time. Therefore, if the reading of one ResultSet object is interleaved
 * with the reading of another, each must have been generated by different
 * Statement objects. All execution methods in the Statement interface
 * implicitly close a statment's current ResultSet object if an open one exists.
 * 
 * @author OmarYousry
 * 
 */
public class JDBCStatement implements Statement {

	private static Logger logger = Logger.getLogger(JDBCStatement.class);

	private static String keywordExc = "ERROR : YOU CAN NOT USE A KEYWORD AS AN ATTRIBUTE NAME";
	private static String resourceNotFound = "ERROR : THIS RESOURCE IS NOT FOUND";
	private static String undifinedSQL = "ERROR : THIS IS NOT A SQL STATEMENT";
	private static String wrongIntialExc = "Error : Wrong Statement initialization";

	private static String stringPat = "(.*)";

	private static String[] keywords = { "(?i)from", "(?i)where", "(?i)set",
			"(?i)values", "(?i)delete", "(?i)select", "(?i)create",
			"(?i)database", "(?i)table", "(?i)use", "(?i)update",
			"((?i)insert)", "((?i)into)" };

	private static String nameReq = "([A-Za-z][A-Za-z0-9]*)";

	private static String selectSpecificPat = "((?i)select)\\s\\(\\s" + "("
			+ nameReq + "\\s\\,\\s" + ")*" + nameReq
			+ "{1}\\s\\)\\s((?i)from)\\s" + nameReq;

	private static String selectAllPat = "((?i)select)\\s"
			+ "\\*\\s((?i)from)\\s" + nameReq;

	private static String deletePat = "((?i)delete)\\s((?i)from)\\s" + nameReq;

	private static String colValPat = nameReq + "\\s\\=\\s" + stringPat;

	private static String updatePat = "((?i)update)\\s" + nameReq
			+ "\\s((?i)set)\\s" + "(" + colValPat + "\\s\\,\\s" + ")*"
			+ colValPat + "{1}";

	private static String usePat = "((?i)use)\\s" + nameReq;

	private static String createDatabasePat = "((?i)create)\\s((?i)database)\\s"
			+ nameReq;

	private static String column_Name_Type = nameReq + "\\s" + stringPat;

	private static String createTablePat = "((?i)create)\\s((?i)table)\\s"
			+ nameReq + "\\s\\(\\s" + "(" + column_Name_Type + "\\s,\\s" + ")*"
			+ column_Name_Type + "{1}\\s\\)";

	private static String insertIntoPat = "((?i)insert)\\s((?i)into)\\s"
			+ nameReq + "\\s\\(\\s" + "(" + nameReq + "\\s\\,\\s" + ")*"
			+ nameReq + "{1}\\s\\)\\s((?i)values)\\s\\(\\s" + "(" + stringPat
			+ "," + ")*" + stringPat + "{1}\\s\\)";

	/**
	 * this specifies the time limit after which the query is stopped, measured
	 * in milliseconds, at initialization it will equal 0, which means
	 * unlimited.
	 */
	private int queryTimeout = 0;

	/**
	 * the connection that created this statement
	 */
	private Connection connection = null;

	/**
	 * A queue to hold the SQL queries in order (FIFO)
	 */
	private Queue<String> sqlBatch = null;

	/**
	 * Holds the result of the last executed SQL query.
	 */
	private ResultSet currentResultSet = null;

	/**
	 * Holds the
	 */
	private int currentUpdateCount = -1;

	/**
	 * A DBMS delegate to execute the actual SQL commands
	 */
	private DBMS dbms;
	private String testString;

	public String getTestString() {
		return testString;
	}

	public void setTestString(String testString) {
		this.testString = testString;
	}

	/**
	 * Constructor
	 * 
	 */

	public JDBCStatement(DBMS dbms, Connection c) throws SQLException {
		if (dbms == null || c == null)
			throw new SQLException(wrongIntialExc);

		this.connection = c;
		this.dbms = dbms;
		this.sqlBatch = new LinkedList<String>();
	}

	/**
	 * Executes the given SQL statement: This method will return true if the SQL
	 * query was a SELECT, or false if it was anUPDATE, INSERT, DELETE, USE or
	 * CRETAE statement.
	 * 
	 * If the statement was a SELECT query, you can retrieve the results by
	 * calling the getResultSet() method.
	 * 
	 * If the statement was an UPDATE, INSERT, DELETE, USE or CRETAE statement,
	 * you can retrieve the affected rows count by calling getUpdateCount()
	 */

	@Override
	public boolean execute(String sql) throws SQLException {
		sql = prepareSQLStatement(sql);
		String isSelect = sql.split(" ")[0];
		logger.info("Trying to Exceute : " + sql);
		if (isSelect.equalsIgnoreCase("select")) {
			executeQuery(sql);
			return true;
		} else {
			executeUpdate(sql);
			return false;
		}
	}

	/**
	 * Executes the given SQL query (SELECT statement), which returns a single
	 * ResultSet object.
	 */
	@Override
	public ResultSet executeQuery(String sql) throws SQLException {
		try {
			currentUpdateCount = -1;
			sql = prepareSQLStatement(sql);
			logger.info("Executing Select Query : " + sql);
			handleSelectComm(sql);
			return currentResultSet;
		} catch (Exception e) {
			logger.error(e.getMessage());
			throw new SQLException(e.getMessage());
		}
	}

	/**
	 * Executes the given SQL statement, which may be an INSERT, UPDATE, or
	 * DELETE statement or an SQL statement that returns nothing.
	 * 
	 * This method returns the number of rows matched by the update statement,
	 * not the number of rows that were modified.
	 */
	@Override
	public int executeUpdate(String sql) throws SQLException {
		try {
			if (currentResultSet != null) {
				currentResultSet.close();
				currentResultSet = null;
			}
			sql = prepareSQLStatement(sql);
			logger.info("Executing Update Statement : " + sql);
			if (sql.matches(usePat)) {
				callUse(sql);
				testString = "used";
			} else if (sql.matches(createDatabasePat)) {
				callCreateDB(sql);
				testString = "DataBase Created";
			} else if (sql.matches(createTablePat)) {
				callCreateTable(sql);
				testString = "Table Created";
			} else {
				handleGeneralCommand(sql);
			}
			return currentUpdateCount;
		} catch (Exception e) {
			logger.error(e.getMessage());
			throw new SQLException(e.getMessage());
		}
	}

	/**
	 * Adds the given SQL command to the current list of commands for this
	 * Statement object.
	 */
	@Override
	public void addBatch(String sql) throws SQLException {
		if (sqlBatch == null) {
			sqlBatch = new LinkedList<String>();
		}
		if (sql != null) {
			sqlBatch.offer(sql);
		}
	}

	/**
	 * Empties this Statement object's current list of SQL commands.
	 */
	@Override
	public void clearBatch() throws SQLException {
		if (sqlBatch != null) {
			sqlBatch.clear();
		}
	}

	/**
	 * Submits a batch of commands to the database for execution and if all
	 * commands execute successfully, returns an array of update counts.
	 */
	@Override
	public int[] executeBatch() throws SQLException {
		if (sqlBatch == null) {
			return null;
		}
		int[] updateCounts = new int[sqlBatch.size()];
		int i = 0;
		while (!sqlBatch.isEmpty()) {
			String command = sqlBatch.poll();
			execute(command);
			updateCounts[i++] = currentUpdateCount;
		}
		return updateCounts;
	}

	/**
	 * Releases this Statement object's database and JDBC resources immediately
	 * instead of waiting for this to happen when it is automatically closed.
	 * 
	 * When a Statement is closed, its current ResultSet, if one exists, is also
	 * closed.
	 */
	@Override
	public void close() throws SQLException {

		if (connection != null) {
			connection.close();
			connection = null;
		}
		if (sqlBatch != null) {
			clearBatch();
			sqlBatch = null;
		}
		if (currentResultSet != null) {
			currentResultSet.close();
			currentResultSet = null;
		}
		currentUpdateCount = -1;
		dbms = null;
	}

	/**
	 * Retrieves the Connection object that produced this Statement object.
	 */
	@Override
	public Connection getConnection() throws SQLException {
		return connection;
	}

	/**
	 * Retrieves the number of seconds the driver will wait for a Statement
	 * object to execute.
	 */
	@Override
	public int getQueryTimeout() throws SQLException {
		return (queryTimeout / 1000);
	}

	/**
	 * Sets the number of seconds the driver will wait for a Statement object to
	 * execute to the given number of seconds. By default there is no limit on
	 * the amount of time allowed for a running statement to complete. If the
	 * limit is exceeded, an SQLTimeoutException is thrown. A JDBC driver must
	 * apply this limit to the execute, executeQuery and executeUpdate methods.
	 * 
	 * Note: In the case of Statement batching, This implementation applies the
	 * time-out to individual SQL statements, and not the entire batch.
	 */
	@Override
	public void setQueryTimeout(int seconds) throws SQLException {
		queryTimeout = 1000 * seconds;
	}

	// --------------------------------------------------------------------\\
	// /////////--------- EXTRA BUT NECESSARY 2 METHODS ----------\\\\\\\\\ \\
	// ----------------------------------------------------------------------\\

	/**
	 * Retrieves the current result as a ResultSet object.
	 */

	@Override
	public ResultSet getResultSet() throws SQLException {
		return currentResultSet;
	}

	/**
	 * Retrieves the current result as an update count; if the result is a
	 * ResultSet object or there are no more results, -1 is returned.
	 */

	@Override
	public int getUpdateCount() throws SQLException {
		return currentUpdateCount;
	}

	// --------------------------------------------------------------------\\
	// ////////////--------- PRIVATE HELPING METHODS ----------\\\\\\\\\\\\ \\
	// ----------------------------------------------------------------------\\

	private void handleGeneralCommand(String sql) throws Exception {
		String[] sqlSplitted = sql.split("\\s((?i)where)\\s");
		if (sqlSplitted.length > 2)
			throw new SQLException(keywordExc);
		String splitMatch = evaluateMatched(sqlSplitted[0]);
		String origMatch = evaluateMatched(sql);
		boolean isValidStmnt = splitMatch != null && sqlSplitted.length == 2
				|| origMatch != null && sqlSplitted.length == 1;
		if (!isValidStmnt) {
			currentUpdateCount = -1;
			throw new SQLException(undifinedSQL);
		}
		String notNull = splitMatch != null ? splitMatch : origMatch;
		if (notNull.equals(updatePat)) {
			callUpdate(sqlSplitted);
			testString = "updated";
		} else if (notNull.equals(deletePat)) {
			callDelete(sqlSplitted);
			testString = "deleted";
		} else if (notNull.equals(insertIntoPat)) {
			callInsert(sqlSplitted);
			testString = "inserted";
		}
	}

	private void callCreateDB(String sql) throws Exception {
		currentUpdateCount = -1;
		String dbName = sql.split(" ")[2];
		if (isKeyword(dbName))
			throw new Exception(keywordExc);
		dbms.createDB(dbName);
	}

	private void callCreateTable(String sql) throws Exception {
		currentUpdateCount = -1;
		String tbName = sql.split(" ")[2];
		String[] cols_names_types = extractColumnsNames(sql);
		ColumnIdentifier[] colsID = new ColumnIdentifier[cols_names_types.length];
		for (int i = 0; i < cols_names_types.length; i++) {
			String[] bySpace = cols_names_types[i].split(" ");
			for (int j = 0; j < bySpace.length; j++) {
				if (isKeyword(bySpace[j]))
					throw new Exception(keywordExc);
			}
			colsID[i] = new ColumnIdentifier(bySpace);
		}
		if (isKeyword(tbName))
			throw new Exception(keywordExc);

		dbms.getUsedDB().addTable(tbName, colsID);
	}

	private void callUse(String sql) throws Exception {
		currentUpdateCount = -1;
		String DBName = sql.split(" ")[1];
		dbms.setUsedDB(DBName);
	}

	private void callInsert(String[] sqlSplitted) throws Exception {
		currentUpdateCount = -1;
		String tbName = sqlSplitted[0].split(" ")[2];
		Table tb = dbms.getUsedDB().getTable(tbName);
		if (tb == null) {
			throw new Exception(resourceNotFound);
		}
		String[] colsNames = extractColumnsNames(sqlSplitted[0]);
		String[] tempArr = sqlSplitted[0].split("\\s((?i)values)\\s");
		if (tempArr.length != 2)
			throw new Exception(keywordExc);
		tb.insert(new Record(colsNames, extractColumnsNames(tempArr[1]), tb));
	}

	private void callDelete(String[] sqlSplitted) throws Exception {
		String tbName = sqlSplitted[0].split(" ")[2];
		Table tb = dbms.getUsedDB().getTable(tbName);
		if (tb == null) {
			currentUpdateCount = -1;
			throw new Exception(resourceNotFound);
		}
		Condition c = null;
		if (sqlSplitted.length == 2)
			c = new Condition(sqlSplitted[1], tb);
		currentUpdateCount = tb.delete(c);
	}

	private void callUpdate(String[] sqlSplitted) throws Exception {
		String[] setSplitted = sqlSplitted[0].split("\\s((?i)set)\\s");

		if (setSplitted.length != 2)
			throw new Exception(keywordExc);

		String[] afterSet = setSplitted[1].split(" , ");

		String[] columnsNames = new String[afterSet.length];
		String[] values = new String[afterSet.length];

		for (int i = 0; i < afterSet.length; i++) {
			String[] splittedVals = afterSet[i].split(" = ");
			columnsNames[i] = splittedVals[0];
			values[i] = splittedVals[1];
		}
		String tbName = sqlSplitted[0].split(" ")[1];
		Table tb = dbms.getUsedDB().getTable(tbName);

		if (tb == null) {
			currentUpdateCount = -1;
			throw new Exception(resourceNotFound);
		}
		Condition c = null;

		if (sqlSplitted.length == 2)
			c = new Condition(sqlSplitted[1], tb);

		currentUpdateCount = tb.update(columnsNames, values, c);
	}

	private void handleSelectComm(String sql) throws Exception {
		String[] sqlSplitted = sql.split("\\s((?i)where)\\s");
		if (sqlSplitted.length > 2)
			throw new SQLException(keywordExc);
		boolean isValidSelect = (sqlSplitted.length == 2 && sqlSplitted[0]
				.matches(selectSpecificPat))
				|| (sqlSplitted.length == 1 && (sql.matches(selectSpecificPat) || sql
						.matches(selectAllPat)));
		if (!isValidSelect) {
			currentResultSet = null;
			throw new Exception(undifinedSQL);
		}
		callSelect(sqlSplitted);
		testString = "selected";
	}

	// to be called after regex validation
	private void callSelect(String[] sqlSplitted) throws Exception {
		String[] fromSplitted = sqlSplitted[0].split("\\s((?i)from)\\s");
		String tableName = fromSplitted[1];
		// may through NullPointerException, handled
		Table tb = dbms.getUsedDB().getTable(tableName);
		if (tb == null) {
			currentResultSet = null;
			throw new Exception(resourceNotFound);
		}
		String[] colmsNames = tb.getColNames();
		Condition c = null;
		if (sqlSplitted.length == 2) {
			c = new Condition(sqlSplitted[1], tb);
			colmsNames = extractColumnsNames(sqlSplitted[0]);
		}
		currentResultSet = new JDBCResultSet(tb.select(colmsNames, c), this);
	}

	// ////////////////////////////////////////////////////////////
	private void canNotExecuteState() throws SQLException {
		currentUpdateCount = -1;
		if (currentResultSet != null) {
			currentResultSet.close();
			currentResultSet = null;
		}
	}

	private String prepareSQLStatement(String sql) throws SQLException {
		if (sql == null || (sql = sql.trim()).equals("")) {
			canNotExecuteState();
			throw new SQLException(undifinedSQL);
		}
		sql = sql.replaceAll("\\*", " * ");
		sql = sql.replaceAll("\\(", " ( ");
		sql = sql.replaceAll("\\)", " ) ");
		sql = sql.replaceAll("\\,", " , ");
		sql = sql.replaceAll("\\=", " = ");
		while (sql.contains("  "))
			sql = sql.replaceAll("  ", " ");
		return sql.trim();
	}

	// to be called after regex validation
	private String[] extractColumnsNames(String string) throws Exception {

		int indexOfOpenPar = string.indexOf('(');
		int indexOfClosedPar = string.indexOf(')');

		if (indexOfOpenPar < 0 || indexOfClosedPar < 0)
			throw new Exception(undifinedSQL);

		String toBeSplitted = string.substring(indexOfOpenPar + 1,
				indexOfClosedPar);
		return toBeSplitted.trim().split(" , ");
	}

	private boolean isKeyword(String str) throws NullPointerException {
		if (str != null) {
			for (int i = 0; i < keywords.length; i++) {
				if (str.matches(keywords[i]))
					return true;
			}
			return false;
		}
		throw new NullPointerException();
	}

	private String evaluateMatched(String str) {
		if (str.matches(updatePat)) {
			return updatePat;
		} else if (str.matches(deletePat)) {
			return deletePat;
		} else if (str.matches(insertIntoPat)) {
			return insertIntoPat;
		} else {
			return null;
		}
	}

	public static void main(String[] args) {
		String ss1 = "create database omar";
		String ss2 = "use omar";
		String ss3 = "create table koko (c1 Integer , c2 Varchar , c3 boolean)";
		String ss4 = "insert into koko (c1 , c2 , c3) values (20 , mariam , true)";
		// String jj1 = "insert into koko (c1 , c2) values (10, omar)";

		String ss5 = "insert into koko (c1 , c3 ) values (20 , true)";
		String ss6 = "insert into koko (c3 , c2 ) values (false , 'boody')";
		String ss7 = "insert into koko (c3 , c3 ) values (false , true)";
		String ss8 = "insert into koko (c2 , c3 ) values ('mariam' , true)";
		String ss9 = "select* from koko";
		//
		// String xx3 =
		// "create table newTb2 (r1 Integer , r2 Varchar , r3 boolean)";
		// String xx4 =
		// "insert into newTb2 (r1 , r2 , r3) values (10 , 'omar' , true)";
		// String xx5 = "insert into newTb2 (r1 , r3 ) values (20 , true)";
		// String xx6 =
		// "insert into newTb2 (r3 , r2 ) values (false , 'boody')";
		// String xx7 = "insert into newTb2 (r3 , r3 ) values (false , true)";
		// String xx8 =
		// "insert into newTb2 (r2 , r3 ) values ('mariam' , true)";
		// String xx9 = "select* from newTb ";
		//
		// // String ss10 = "select from newTb ";

		// String ss11 = "select (c1, c2) from newTb where c3 = true";
		// String ss12 = "delete from newTb where c3 = true";
		Statement s = null;

		try {
			DBMS ddd = new StdDBMS();
			s = new JDBCStatement(ddd, new JDBCConnection(ddd));

			s.execute(ss1);
			s.execute(ss2);
			s.execute(ss3);
			s.execute(ss4);
			s.execute(ss5);
			s.execute(ss6);
			s.execute(ss7);
			s.execute(ss8);
			s.execute(ss9);
			// s.execute(ss10);
			// s.execute(ss11);
			// s.execute(ss12);
			s.getConnection().close();
		} catch (Exception e) {
			System.out.println("LOL!");
			e.printStackTrace();
		}

	}

	// ------------------------------------------------------\\
	// /////////--------- UNUSED METHODS ----------\\\\\\\\\\ \\
	// --------------------------------------------------------\\

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		return false;
	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		return null;
	}

	@Override
	public void cancel() throws SQLException {
	}

	@Override
	public void clearWarnings() throws SQLException {
	}

	@Override
	public void closeOnCompletion() throws SQLException {
	}

	@Override
	public boolean execute(String sql, int autoGeneratedKeys)
			throws SQLException {
		return false;
	}

	@Override
	public boolean execute(String sql, int[] columnIndexes) throws SQLException {
		return false;
	}

	@Override
	public boolean execute(String sql, String[] columnNames)
			throws SQLException {
		return false;
	}

	@Override
	public int executeUpdate(String sql, int autoGeneratedKeys)
			throws SQLException {
		return 0;
	}

	@Override
	public int executeUpdate(String sql, int[] columnIndexes)
			throws SQLException {
		return 0;
	}

	@Override
	public int executeUpdate(String sql, String[] columnNames)
			throws SQLException {
		return 0;
	}

	@Override
	public int getFetchDirection() throws SQLException {
		return 0;
	}

	@Override
	public int getFetchSize() throws SQLException {
		return 0;
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		return null;
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		return 0;
	}

	@Override
	public int getMaxRows() throws SQLException {
		return 0;
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		return false;
	}

	@Override
	public boolean getMoreResults(int current) throws SQLException {
		return false;
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		return 0;
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		return 0;
	}

	@Override
	public int getResultSetType() throws SQLException {
		return 0;
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		return null;
	}

	@Override
	public boolean isCloseOnCompletion() throws SQLException {
		return false;
	}

	@Override
	public boolean isClosed() throws SQLException {
		return false;
	}

	@Override
	public boolean isPoolable() throws SQLException {
		return false;
	}

	@Override
	public void setCursorName(String name) throws SQLException {
	}

	@Override
	public void setEscapeProcessing(boolean enable) throws SQLException {
	}

	@Override
	public void setFetchDirection(int direction) throws SQLException {
	}

	@Override
	public void setFetchSize(int rows) throws SQLException {
	}

	@Override
	public void setMaxFieldSize(int max) throws SQLException {
	}

	@Override
	public void setMaxRows(int max) throws SQLException {
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
	}

}
